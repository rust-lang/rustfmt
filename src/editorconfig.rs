mod maybe_unset;
mod serialization;
mod values;

use std::fmt::{Display, Write};

use maybe_unset::MaybeUnset;
use values::{CharSet, EOFControllChar, IndentSize, IndentStyle};

pub use maybe_unset::UnsetBehaviour;
pub use serialization::*;

use crate::Config;

#[derive(Clone)]
pub struct EditorConfig {
    indent_style: MaybeUnset<IndentStyle>,
    indent_size: MaybeUnset<IndentSize>,
    tab_width: MaybeUnset<usize>,
    end_of_line: MaybeUnset<EOFControllChar>,
    charset: MaybeUnset<CharSet>,
    spelling_language: MaybeUnset<String>,
    trim_trailing_whitespace: MaybeUnset<bool>,
    insert_final_newline: MaybeUnset<bool>,
    // Not universsally supported options
    max_line_length: MaybeUnset<usize>,
}

impl<'a> From<&'a Config> for EditorConfig {
    fn from(value: &'a Config) -> Self {
        Self {
            indent_style: MaybeUnset::Set(match value.hard_tabs() {
                true => IndentStyle::Tab,
                false => IndentStyle::Space,
            }),
            indent_size: MaybeUnset::Set(IndentSize::Tab), // Always use tab width for indent_size
            tab_width: MaybeUnset::Set(value.tab_spaces()),
            end_of_line: EOFControllChar::from_newline_style(&value.newline_style()).into(),
            charset: MaybeUnset::Set(CharSet::UTF8), // All rust files are UTF-8
            spelling_language: MaybeUnset::Unset,
            trim_trailing_whitespace: MaybeUnset::Set(true), // I think rustfmt always does this
            insert_final_newline: MaybeUnset::Set(true),     // I think rustfmt always does this
            max_line_length: MaybeUnset::Set(value.max_width()),
        }
    }
}

impl Default for EditorConfig {
    fn default() -> Self {
        Config::default().into()
    }
}

impl From<Config> for EditorConfig {
    fn from(value: Config) -> Self {
        Self::from(&value)
    }
}

fn write_pair<W: Write, V: Display>(
    target: &mut W,
    key: &str,
    val: &MaybeUnset<V>,
    b: UnsetBehaviour,
) -> std::fmt::Result {
    match val {
        MaybeUnset::Unset => match b {
            UnsetBehaviour::Omit => Ok(()),
            UnsetBehaviour::Emit => writeln!(target, "{}", MaybeUnset::<V>::UNSET_VAL),
        },
        MaybeUnset::Set(val) => writeln!(target, "{key} = {val}"),
    }
}

macro_rules! write_multiple_pairs {
    ($self: ident, $target: ident, $unset_behaviour: ident, $($kname: ident),* $(,)?) => {
        $(match write_pair($target, stringify!($kname), &$self.$kname, $unset_behaviour) {
            Ok(_) => (),
            Err(err) => return Err(err)
        }
        )*

    };
}

impl EditorConfig {
    pub fn write_to<W: Write>(
        &self,
        target: &mut W,
        unset_behaviour: UnsetBehaviour,
    ) -> std::fmt::Result {
        write!(
            target,
            "# Generated by rustfmt version: {}\n\n[*.rs]\n",
            option_env!("CARGO_PKG_VERSION").unwrap_or("unknown")
        )?;
        write_multiple_pairs!(
            self,
            target,
            unset_behaviour,
            indent_style,
            indent_size,
            tab_width,
            end_of_line,
            charset,
            spelling_language,
            trim_trailing_whitespace,
            insert_final_newline,
            max_line_length
        );
        Ok(())
    }
}
