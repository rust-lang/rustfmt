mod maybe_unset;
mod serialization;
mod values;

use std::fmt::{Display, Write};

use maybe_unset::MaybeUnset;
use values::{CharSet, EOLControllChar, IndentSize, IndentStyle};

pub use maybe_unset::UnsetBehaviour;
pub use serialization::*;

use crate::{Config, version_str};

#[derive(Clone)]
pub struct EditorConfig {
    indent_style: MaybeUnset<IndentStyle>,
    indent_size: MaybeUnset<IndentSize>,
    tab_width: MaybeUnset<usize>,
    end_of_line: MaybeUnset<EOLControllChar>,
    charset: MaybeUnset<CharSet>,
    trim_trailing_whitespace: MaybeUnset<bool>,
    insert_final_newline: MaybeUnset<bool>,
    // Not universsally supported options
    max_line_length: MaybeUnset<usize>,
}

impl<'a> From<&'a Config> for EditorConfig {
    fn from(value: &'a Config) -> Self {
        Self {
            indent_style: MaybeUnset::Set(match value.hard_tabs() {
                true => IndentStyle::Tab,
                false => IndentStyle::Space,
            }),
            indent_size: MaybeUnset::Set(IndentSize::Tab), // Always use tab width for indent_size
            tab_width: MaybeUnset::Set(value.tab_spaces()),
            end_of_line: EOLControllChar::from_newline_style(&value.newline_style()).into(),
            charset: MaybeUnset::Set(CharSet::UTF8), // All rust files are UTF-8
            trim_trailing_whitespace: MaybeUnset::Set(true), // I think rustfmt always does this
            insert_final_newline: MaybeUnset::Set(true), // I think rustfmt always does this
            max_line_length: MaybeUnset::Set(value.max_width()),
        }
    }
}

impl Default for EditorConfig {
    fn default() -> Self {
        Config::default().into()
    }
}

impl From<Config> for EditorConfig {
    fn from(value: Config) -> Self {
        Self::from(&value)
    }
}

fn write_pair<W: Write, V: Display>(
    target: &mut W,
    key: &str,
    val: &MaybeUnset<V>,
    b: UnsetBehaviour,
) -> std::fmt::Result {
    match val {
        MaybeUnset::Unset => match b {
            UnsetBehaviour::Omit => Ok(()),
            UnsetBehaviour::Emit => writeln!(target, "{key} = {}", MaybeUnset::<V>::UNSET_VAL),
        },
        MaybeUnset::Set(val) => writeln!(target, "{key} = {val}"),
    }
}

macro_rules! write_multiple_pairs {
    ($self: ident, $target: ident, $unset_behaviour: ident, $($kname: ident),* $(,)?) => {
        $(match write_pair($target, stringify!($kname), &$self.$kname, $unset_behaviour) {
            Ok(_) => (),
            Err(err) => return Err(err)
        }
        )*

    };
}

impl EditorConfig {
    pub fn write_to<W: Write>(
        &self,
        target: &mut W,
        unset_behaviour: UnsetBehaviour,
    ) -> std::fmt::Result {
        write!(
            target,
            "# Generated by rustfmt version: {}\n\n[*.rs]\n",
            version_str()
        )?;
        write_multiple_pairs!(
            self,
            target,
            unset_behaviour,
            indent_style,
            indent_size,
            tab_width,
            end_of_line,
            charset,
            trim_trailing_whitespace,
            insert_final_newline,
            max_line_length
        );
        Ok(())
    }
}

#[cfg(test)]
mod unit_tests {
    use std::path::Path;

    use crate::Config;

    use super::EditorConfig;

    fn assert_config_eq(config: &Config, editorconfig: &EditorConfig) {
        assert_eq!(config.hard_tabs(), editorconfig.indent_style.is_tab(),);
        assert!(editorconfig.indent_size.is_tab(),);
        assert_eq!(config.tab_spaces(), editorconfig.tab_width.clone().unwrap(),);
        assert_eq!(config.newline_style(), editorconfig.end_of_line);
        assert!(editorconfig.trim_trailing_whitespace.clone().unwrap());
        assert!(editorconfig.insert_final_newline.clone().unwrap());
        assert_eq!(
            config.max_width(),
            editorconfig.max_line_length.clone().unwrap()
        )
    }

    fn test_config(config: &Config) {
        let editorconfig: EditorConfig = config.into();
        assert_config_eq(config, &editorconfig);
    }

    #[test]
    fn from_config() {
        let config = Config::default();
        test_config(&config);
    }

    fn from_toml(toml: &str) -> Config {
        Config::from_toml(toml, Path::new("./rustfmt.toml")).unwrap()
    }

    fn test_toml(toml: &str) {
        let config = from_toml(toml);
        test_config(&config);
    }

    #[test]
    fn from_config_all_custom() {
        test_toml("hard_tabs = true\ntab_spaces = 8\nnewline_style = \"Native\"\nmax_width = 2000")
    }

    #[test]
    fn from_config_some_custom() {
        test_toml("hard_tabs = true\ntab_spaces = 8")
    }

    #[test]
    fn auto_newline_style() {
        let conf: EditorConfig = from_toml("newline_style = \"Auto\"").into();
        assert!(conf.end_of_line.is_unset());
    }
}
