// rustfmt-version: Two 
fn main() {

    // first sample
    {{{{{
        let push_ident = if let Some(&node_id) =
            subgraph_nodes.get(pull_to_push_idx)
        {
            self.node_id_as_ident(node_id, false)
        } else {
            // Entire subgraph is pull (except for a single send/push handoff output).
            assert_eq!(
                1,
                send_ports.len(),
                "If entire subgraph is pull, should have only one handoff output."
            );
            send_ports[0].clone()
        };
    }}}}}

    // second sample
    {{{{{
        let push_ident = if let Some(&node_id) =
            subgraph_nodes.get(pull_to_push_idx)
        {
            self.node_id_as_ident(node_id, false)
        } else {
            // Entire subgraph is pull (except for a single send/push handoff output).
            assert_eq!(
                1,
                send_ports.len(),
                "If entire subgraph is pull, should have only one handoff output."
            );
            send_ports[0].clone()
        };
    }}}}}

    // third sample
    {{{{{
        let push_ident = if let Some(&node_id) =
            subgraph_nodes.get(pull_to_push_idx)
        {
            self.node_id_as_ident(node_id, false)
        } else {
            // Entire subgraph is pull (except for a single send/push handoff output).
            assert_eq!(
                1,
                send_ports.len(),
                "If entire subgraph is pull, should have only one handoff output."
            );
            send_ports[0].clone()
        };
    }}}}}

    // fourth sample
    {{{{{
        let push_ident =
            if let Some(&node_id) = subgraph_nodes.get(pull_to_push_idx) {
                self.node_id_as_ident(node_id, false)
            } else {
                // Entire subgraph is pull (except for a single send/push handoff output).
                assert_eq!(
                    1,
                    send_ports.len(),
                    "If entire subgraph is pull, should have only one handoff output."
                );
                send_ports[0].clone()
            };
    }}}}}

    // fifth sample
    {{{{{
        let push_ident =
            if let Some(&node_id) = subgraph_nodes.get(pull_to_push_idx) {
                self.node_id_as_ident(node_id, false)
            } else {
                // Entire subgraph is pull (except for a single send/push handoff output).
                assert_eq!(
                    1,
                    send_ports.len(),
                    "If entire subgraph is pull, should have only one handoff output."
                );
                send_ports[0].clone()
            };
    }}}}}

    // sixth sample
    {{{{{
        let push_ident = if let Some(&node_id) =
            subgraph_nodes.get(pull_to_push_idx)
        {
            self.node_id_as_ident(node_id, false)
        } else {
            // Entire subgraph is pull (except for a single send/push handoff output).
            assert_eq!(
                1,
                send_ports.len(),
                "If entire subgraph is pull, should have only one handoff output."
            );
            send_ports[0].clone()
        };
    }}}}}

    // seventh sample
    {{{{{
        let push_ident = if let Some(&node_id) =
            subgraph_nodes.get(pull_to_push_idx)
        {
            self.node_id_as_ident(node_id, false)
        } else {
            // Entire subgraph is pull (except for a single send/push handoff output).
            assert_eq!(
                1,
                send_ports.len(),
                "If entire subgraph is pull, should have only one handoff output."
            );
            send_ports[0].clone()
        };
    }}}}}
}
